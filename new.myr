use std
use bio

type xml = struct
	file	:	bio.file#
	buf	:	byte[:]
	bidx	:	std.size
	bcur	:	std.size
	line	:	std.size
	off	:	std.size
	state	:	state
;;

type errtype = union
	`Empty
	`Inval	char
	`Junk	char
	`Trunc	bio.err
	`NYI
;;

type state = union
	`Open
	`Close
;;

type event = union
	`Start		(byte[:], (byte[:], byte[:])[:])
	`Characters	byte[:]
;;

const parse = {x
	match x.state
	| `Open:	-> open(x)
	| `Close:	-> close(x)
	;;
}

const close = {x
	x.state = `Open

	match bio.readto(x.file, "<")
	| `std.Ok s:
		if std.strstrip(s).len > 0
			-> `std.Ok `Characters s
		else
			std.slfree(s)
			-> parse(x)
		;;
	| `std.Err e:
		-> `std.Err `Trunc e
	;;
}

const open = {x
	x.state = `Close

	match bio.peekc(x.file)
	| `std.Ok '!':	/* XXX */
	| `std.Ok '/':	/* XXX */
	| `std.Ok '?':	/* XXX */
	| `std.Ok '>':	-> `std.Err `Empty
	| `std.Ok _:	-> elemname(x)
	| `std.Err e:	-> `std.Err `Trunc e
	;;

	-> `std.Err `NYI
}

const elemname = {x
	var start, stop

	match bio.readto(x.file, ">")
	| `std.Ok s:
		newbuf(x, s)
		match bnext(x)
		| c:
			if namestartchar(c)
				start = stop = x.bcur
			else
				-> `std.Err `Inval c
			;;
		;;
		for c : std.bychar(x.buf[x.bidx:])
			x.bidx += std.charlen(c)
			match c
			| '>':	break
			| _:
				if namechar(c)
					stop = x.bidx
				elif isspace(c)
					eatspace(x)
					break
				else
					-> `std.Err `Inval c
				;;
			;;
		;;

		-> `std.Ok `Start (x.buf[start:stop], [][:])
	| `std.Err e:
		-> `std.Err `Trunc e
	;;
}

/*const fnext = {x
	var c

	match bio.getc(x.file)
	| `std.Ok a:	c = a
	| `std.Err e:	-> `std.Err e
	;;

	if c == '\n'
		x.line++
		x.off = 0
	else
		x.off++
	;;

	-> `std.Ok c
}*/

const bnext = {x
	if x.bidx >= x.buf.len
		-> std.Badchar
	;;

	var c = std.decode(x.buf[x.bidx:])
	x.bcur = x.bidx
	x.bidx += std.charlen(c)

	if c == '\n'
		x.line++
		x.off = 0
	else
		x.off++
	;;

	-> c
}

const newbuf = {x, buf
	std.slfree(x.buf)
	x.bidx = x.bcur = 0
	x.buf = buf
}

/* common chars that a name is allowed to start with */
const namestartcommonchar = {c
	-> c >= 'a' && c <= 'z' || \
	   c >= 'A' && c <= 'Z' || \
	   c == ':' || c == '_'
}

/* the rest of the chars a name can start with */
const namestartotherchar = {c
	-> c >= 0xC0 && c <= 0xD6 || c >= 0xD8 && c <= 0xF6 || \
	   c >= 0xF8 && c <= 0x2FF || \
	   c >= 0x370 && c <= 0x37D || c >= 0x37F && c <= 0x1FFF || \
	   c >= 0x200C && c <= 0x200D || c >= 0x2070 && c <= 0x218F || \
	   c >= 0x2C00 && c <= 0x2FEF || c >= 0x3001 && c <= 0xD7FF || \
	   c >= 0xF900 && c <= 0xFDCF || c >= 0xFDF0 && c <= 0xFFFD || \
	   c >= 0x10000 && c <= 0xEFFFF
}

/* all the chars a name can start with, ascii chars are checked first */
const namestartchar = {c
	-> namestartcommonchar(c) || namestartotherchar(c)
}

/* all the chars that can be in a name, ascii chars are checked first */
const namechar = {c
	-> namestartcommonchar(c) || c >= '0' && c <= '9' || \
	   c == '-' || c == '.' || namestartotherchar(c) || \
	   c == 0xB7 || c >= 0x0300 && c <= 0x036F || \
	   c >= 0x203F && c <= 0x2040
}

/* like std.isspace but for the whitespace characters defined in XML 1.0 */
const isspace = {c
	-> c == ' ' || c == '\n' || c == '\t' || c == '\r'
}

const eatspace = {x
	while true
		match bnext(x)
		| ' ':
		| '\n':
		| '\t':
		| '\r':
		| _:	break
		;;
	;;
}

/* like bio.skipspace but includes \r and increments the offsets */
const skipspace = {x
	while true
		match bio.peekc(x.file)
		| `std.Ok ' ':
		| `std.Ok '\n':
			x.line++
			x.off = 0
			goto nl
		| `std.Ok '\t':
		| `std.Ok '\r':
		| `std.Ok _:
			break
		| `std.Err _:
			break
		;;

		x.off++
:nl
		bio.getc(x.file)
	;;
}

const free = {x
	bio.close(x.file)
	std.slfree(x.buf)
	std.free(x)
}

const main = {
	var x : xml#

	x = std.mk([
		.file = bio.mkmem("<testing thing=\"stuff\"></testing>"),
		.buf = [][:],
		.bidx = 0,
		.bcur = 0,
		.line = 1,
		.off = 0,
		.state = `Close
	])

	skipspace(x)
	std.put("{}\n", parse(x))

	free(x)
}
