use std

use "types"

pkg xml =
	const unescape	:	(s : byte[:] -> std.result(byte[:], byte[:]))
;;

const unescape = {s
	var start, stop, idx
	var sb = std.mksb()
	var err

	idx = start = stop = 0

	while idx < s.len
		var c = std.decode(s[idx:])
		idx += std.charlen(c)

		match c
		| '&':
			std.sbputs(sb, s[start:stop])

			match pentity(s[idx:])
			| `std.Ok (e, i):
				idx += i
				std.sbputb(sb, e)
			| `std.Err e:
				err = e
				goto err
			;;

			start = stop = idx
		| _:
			stop = idx
		;;
	;;

	std.sbputs(sb, s[start:])

	-> `std.Ok std.sbfin(sb)

:err
	std.sbfree(sb)
	-> `std.Err err
}

const pentity = {s
	const delim = ";"
	var index
	var c

	match std.strfind(s, delim)
	| `std.Some in:	index = in
	| `std.None:
		var i = 0
		var z
		while i < s.len
			z = std.decode(s[i:])
			if z == '\r' || std.isspace(z)
				break
			;;
			i += std.charlen(z)
		;;
		-> `std.Err s[:i]
	;;

	match s[:index]
	| "quot":	c = '"'
	| "amp":	c = '&'
	| "apos":	c = '\''
	| "lt":		c = '<'
	| "gt":		c = '>'
	| _:	match pcodepoint(s[:index])
		| `std.Ok e:	c = e
		| `std.Err e:	-> `std.Err e
		;;
	;;

	-> `std.Ok ((c : byte), index + delim.len)
}

const pcodepoint = {s
	var idx = 0
	var base

	match std.decode(s[idx:])
	| '#':	idx += std.charlen('#')
	| _:	-> `std.Err s
	;;

	match std.decode(s[idx:])
	| 'x':
		base = 16
		idx += std.charlen('x')
	| _:
		base = 10
	;;

	match std.intparsebase(s[idx:], base)
	| `std.Some i:	-> `std.Ok i
	| `std.None:	-> `std.Err s
	;;
}
