use std

pkg xml =
	const decode	: (s : byte[:] -> std.result(byte[:], byte[:]))
	const decodex	: (s : byte[:], custom : (byte[:], byte[:])[:] -> std.result(byte[:], byte[:]))
;;

type decoded = union
	`Char		char
	`Byte		byte
	`String		byte[:]
;;

const decode = {s
	-> unescape(s, [][:])
}

const decodex = {s, custom
	-> unescape(s, custom)
}

const unescape = {s, ens
	const delim = ";"
	var start, stop, sidx, eidx
	var sb = std.mksb()

	sidx = eidx = start = stop = 0

	while sidx < s.len
		match std.decode(s[sidx:])
		| '&':
			std.sbputs(sb, s[start:stop])
			match std.strfind(s[sidx:], delim)
			| `std.Some i:
				eidx = i + sidx
			| `std.None:
				eidx = errend(s[sidx:]) + sidx
				goto err
			;;

			match pentity(s[sidx + std.charlen('&'):eidx], ens)
			| `std.Some `Char c:
				std.sbputb(sb, (c : byte))
			| `std.Some `Byte b:
				std.sbputb(sb, b)
			| `std.Some `String sl:
				std.sbputs(sb, sl)
			| `std.None:
				eidx += delim.len
				goto err
			;;

			sidx = eidx + delim.len
			start = stop = sidx
		| c:
			sidx += std.charlen(c)
			stop = sidx
		;;
	;;

	std.sbputs(sb, s[start:])

	-> `std.Ok std.sbfin(sb)

:err
	std.sbfree(sb)
	-> `std.Err s[sidx:eidx]
}

const pentity = {s, cust
	match creference(s)
	| `std.Some c:	-> `std.Some `Byte c
	| `std.None:
	;;

	match s
	|"quot":	-> `std.Some `Char '"'
	|"amp":		-> `std.Some `Char '&'
	|"apos":	-> `std.Some `Char '\''
	|"lt":		-> `std.Some `Char '<'
	|"gt":		-> `std.Some `Char '>'
	| _:
	;;

	for (name, res) : cust
		if std.sleq(name, s)
			-> `std.Some `String res
		;;
	;;

	-> `std.None
}

const creference = {s
	var idx = 0
	var base

	if s.len < 2
		std.put("{}\n", s)
		-> `std.None
	;;

	match std.decode(s)
	| '#':	idx += std.charlen('#')
	| c:	-> `std.None
	;;

	match std.decode(s[idx:])
	| 'x':
		base = 16
		idx += std.charlen('x')
		if s.len <= idx
			-> `std.None
		;;
	| _:
		base = 10
	;;

	-> std.intparsebase(s[idx:], base)
}

/*
 * something started with a & but had no terminating ; so find the first
 * space to return something logical to report as the erroneous token
 */
const errend = {s
	var i = 0
	var c

	while i < s.len
		c = std.decode(s[i:])
		if c == '\r' || std.isspace(c)
			break
		;;
		i += std.charlen(c)
	;;

	-> i
}
