use std

use "types"

pkg xml =
	const unescape	:	(s : byte[:] -> std.result(byte[:], byte[:]))
;;

const unescape = {s
	-> dounescape(s, [
		("quot", '"'),
		("amp", '&'),
		("apos", '\''),
		("lt", '<'),
		("gt", '>')
	][:])
}

const dounescape = {s, ens
	var start, stop, idx
	var sb = std.mksb()
	var err

	idx = start = stop = 0

	while idx < s.len
		var c = std.decode(s[idx:])
		idx += std.charlen(c)

		match c
		| '&':
			std.sbputs(sb, s[start:stop])

			match pentity(s[idx:], ens)
			| `std.Ok (e, i):
				idx += i
				std.sbputb(sb, e)
			| `std.Err e:
				err = e
				goto err
			;;

			start = stop = idx
		| _:
			stop = idx
		;;
	;;

	std.sbputs(sb, s[start:])

	-> `std.Ok std.sbfin(sb)

:err
	std.sbfree(sb)
	-> `std.Err err
}

const pentity = {s, ens
	const delim = ";"
	var index
	var c

	match std.strfind(s, delim)
	| `std.Some in:	index = in
	| `std.None:
		var i = 0
		var z
		while i < s.len
			z = std.decode(s[i:])
			if z == '\r' || std.isspace(z)
				break
			;;
			i += std.charlen(z)
		;;
		-> `std.Err s[:i]
	;;

	if std.decode(s) == '#'
		match pcodepoint(s[:index])
		| `std.Ok ch:
			c = ch
			goto end
		| `std.Err e:
			-> `std.Err e
		;;
	else
		for (name, char) : ens
			if std.sleq(name, s[:index])
				c = char
				goto end
			;;
		;;
	;;

	-> `std.Err s[:index]

:end
	-> `std.Ok ((c : byte), index + delim.len)
}

const pcodepoint = {s
	var idx = 0
	var base

	match std.decode(s[idx:])
	| '#':	idx += std.charlen('#')
	| _:	-> `std.Err s
	;;

	match std.decode(s[idx:])
	| 'x':
		base = 16
		idx += std.charlen('x')
	| _:
		base = 10
	;;

	match std.intparsebase(s[idx:], base)
	| `std.Some i:	-> `std.Ok i
	| `std.None:	-> `std.Err s
	;;
}
