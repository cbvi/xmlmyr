use std
use bio

pkg xml =
	type eventiter = ctx

	type ctx = struct
		file	:	bio.file#
		owned	:	bool
		p	:	parser#
	;;

	type parser = struct
		buf	:	byte[:]
		bidx	:	std.size
		bcur	:	std.size
		line	:	std.size
		off	:	std.size
		state	:	state
		more	:	bool
		error	:	std.option(err)
	;;

	type event = union
		/*
		 * processing instruction <?foo ..?> and prolog <?xml ..?>
		 *
		 * <?target some instruction?>
		 *   -> `xml.Instruction ("target", "some instruction")
		 *
		 * <?xml version='1.0'?>
		 *   -> `xml.Instruction ("xml", "version='1.0'")
		 */
		`Instruction	(byte[:], byte[:])

		/*
		 * doctype <!DOCTYPE ..>
		 *
		 * <!DOCTYPE foo [ <!ENTITY x 'x'> ] >
		 *   -> `xml.Doctype "foo [ <!ENTITY x 'x'> ] >"
		 */
		`Doctype	byte[:]

		/*
		 * end of the file stream was appropriately reached
		 */
		`Eof

		/*
		 * start tag <foo> <foo ..> and empty tag <foo /> <foo ../>
		 *
		 * for an empty tag, the next successful event following
		 * this will be a corresponding end event, ie.
		 * <foo /> will cause the same sequence of events as
		 * <foo></foo>
		 *
		 * contains the name of the tag and a slice of tuples
		 * representing key-value pairs of attributes, or an empty
		 * slice if there are none
		 *
		 * <foo> or <foo />
		 *   -> `xml.Start ("foo", [])
		 *
		 * <foo bar="1" baz="2"> or <foo bar="1" baz="2" />
		 *   -> `xml.Start ("foo", [("bar", "1"), ("baz", "2")])
		 */
		`Start		(byte[:], (byte[:], byte[:])[:])

		/*
		 * end tag </foo> and follow up to empty tag <foo />
		 *
		 * </foo>
		 *   -> `xml.End "foo"
		 *
		 * <foo /> (after start event has been received)
		 *   -> `xml.End "foo"
		 */
		`End		byte[:]

		/*
		 * character data ..> .. <..
		 *
		 * ..>foo<..
		 *   -> `xml.Characters "foo"
		 */
		`Characters	byte[:]

		/*
		 * cdata <![CDATA[..]]>
		 *
		 * <!CDATA[foo]]>
		 *  -> `xml.Cdata "foo"
		 */
		`Cdata		byte[:]

		/*
		 * comment <!-- .. -->
		 *
		 * <!-- foo -->
		 *  -> `xml.Comment "foo"
		 */
		`Comment	byte[:]
	;;

	type mkerr = union
		`Efile		byte[:]	/* file open failed */
		`Eenc		byte[:]	/* file has unsupported encoding */
	;;

	type err = struct
		line	:	std.size
		off	:	std.size
		err	:	errtype
	;;

	type errtype = union
		`Inval		char	/* this char is invalid here */
		`Trunc		bio.err	/* parsing ended due to io err */
		`Unclosed	(byte[:], byte[:]) /* start with no end */
		`Unexpected	(char, char) /* this wasn't that */
	;;

	type state = union
		`Open
		`Close
		`Closing	byte[:]
	;;
;;
