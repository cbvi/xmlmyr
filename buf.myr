use std
use bio

use "err"
use "chars"
use "types"

pkg xml =
	pkglocal const newbuf :		(x : ctx#, buf : byte[:] -> void)
	pkglocal const expandbuf :	(x : ctx#, buf : byte[:] -> void)
	pkglocal const fillbuf :	(x : ctx#, full : byte[:], pref : byte[:], suf : byte[:] -> std.result(byte[:], err))

	pkglocal const bnext :		(x : ctx# -> char)
	pkglocal const bpeek :		(x : ctx# -> char)
	pkglocal const beatspace :	(x : ctx# -> void)
	pkglocal const bskip :		(x : ctx#, n : int -> void)

	pkglocal const startname:	(x : ctx# -> std.result((std.size, std.size), err))
;;

const newbuf = {x, buf
	std.slfree(x.p.buf)
	x.p.bidx = x.p.bcur = 0
	x.p.buf = buf
}

const expandbuf = {x, buf
	x.p.buf = std.sljoin(&x.p.buf, buf)
	std.slfree(buf)
}

const fillbuf = {x, full, pref, suf
	var start, stop

	for p : std.bychar(pref)
		match bio.getc(x.file)
		| `std.Ok c:
			x.p.off += 1
			if c != p
				-> `std.Err error(x, `Unexpected (c, p))
			;;
		| `std.Err e:
			-> `std.Err error(x, `Trunc e)
		;;
	;;


	match bio.readterm(x.file, suf)
	| `std.Ok s:	newbuf(x, s)
	| `std.Err e:	-> `std.Err error(x, `Trunc e)
	;;

	start = x.p.bidx

	while x.p.bidx < x.p.buf.len - suf.len
		bnext(x)
	;;

	stop = x.p.bidx

	for s : std.bychar(suf)
		if s != bnext(x)
			-> `std.Err error(x, `Unclosed (full, suf))
		;;
	;;

	-> `std.Ok x.p.buf[start:stop]
}

const bnext = {x
	var c

	if x.p.bidx >= x.p.buf.len
		-> std.Badchar
	;;

	c = std.decode(x.p.buf[x.p.bidx:])
	x.p.bcur = x.p.bidx
	x.p.bidx += std.charlen(c)

	match c
	| '\n':
		x.p.line++
		x.p.off = 0
	| _:
		x.p.off++
	;;

	-> c
}

const bpeek = {x
	if x.p.bidx < x.p.buf.len
		-> std.decode(x.p.buf[x.p.bidx:])
	else
		-> std.Badchar
	;;
}

const beatspace = {x
	while true
		if isspace(bpeek(x))
			bnext(x)
		else
			break
		;;
	;;
}

const bskip = {x, n
	for var i = 0; i < n; i++
		bnext(x)
	;;
}

const startname = {x
	var c

	if x.p.bidx >= x.p.buf.len
		-> `std.Err error(x, `Trunc `bio.Eof)
	;;

	c = bnext(x)
	if namestartchar(c)
		-> `std.Ok (x.p.bcur, x.p.bidx)
	else
		-> `std.Err error(x, `Inval c)
	;;
}
