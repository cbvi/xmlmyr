use std
use bio

use "err"
use "chars"
use "types"

pkg xml =
	pkglocal const newbuf :		(x : ctx#, buf : byte[:] -> void)
	pkglocal const expandbuf :	(x : ctx#, buf : byte[:] -> void)

	pkglocal const bexpect :	(x : ctx#, want : char -> std.result(void, errtype))
	pkglocal const bget :		(x : ctx# -> std.option(char))
	pkglocal const bnext :		(x : ctx# -> char)
	pkglocal const beatspace :	(x : ctx# -> void)
	pkglocal const bskip :		(x : ctx#, n : int -> void)

	pkglocal const getname :	(x : ctx# -> std.result((std.size, std.size), errtype))
;;

const newbuf = {x, buf
	std.slfree(x.p.buf)
	x.p.bidx = 0
	x.p.buf = buf
}

const expandbuf = {x, buf
	x.p.buf = std.sljoin(&x.p.buf, buf)
	std.slfree(buf)
}

const bexpect = {x, want
	var c

	if x.p.bidx < x.p.buf.len
		c = bnext(x)
		if c == want
			-> `std.Ok void
		else
			-> `std.Err `Unexpected (c, want)
		;;
	else
		-> `std.Err `Trunc `bio.Eof
	;;
}

const bget = {x
	if x.p.bidx < x.p.buf.len
		-> `std.Some bnext(x)
	else
		-> `std.None
	;;
}

const bnext = {x
	var c

	c = std.decode(x.p.buf[x.p.bidx:])
	x.p.bidx += std.charlen(c)

	match c
	| '\n':
		x.p.line++
		x.p.off = 0
	| _:
		x.p.off++
	;;

	-> c
}

const beatspace = {x
	var p
	while true
		p = std.decode(x.p.buf[x.p.bidx:])
		match p
		| ' ':
		| '\n':
			x.p.line++
			x.p.off = 0
			goto next
		| '\t':
		| '\r':
		| _:
			break
		;;
		x.p.off++
:next
		x.p.bidx += std.charlen(p)
	;;
}

const bskip = {x, n
	for var i = 0; i < n; i++
		bnext(x)
	;;
}

const getname = {x
	var c
	var start

	if x.p.bidx >= x.p.buf.len
		-> `std.Err `Trunc `bio.Eof
	;;

	start = x.p.bidx
	c = bnext(x)
	if !namestartchar(c)
		-> `std.Err `Inval c
	;;

	while x.p.bidx < x.p.buf.len
		c = std.decode(x.p.buf[x.p.bidx:])
		if namechar(c)
			x.p.off++
			x.p.bidx += std.charlen(c)
		else
			break
		;;
	;;

	-> `std.Ok (start, x.p.bidx)
}
