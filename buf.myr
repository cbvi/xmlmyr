use std
use bio

use "err"
use "chars"
use "types"

pkg xml =
	pkglocal const newbuf :		(x : ctx#, buf : byte[:] -> void)
	pkglocal const refillbuf :	(x : ctx# -> refill)

	pkglocal const bexpect :	(x : ctx#, want : byte[:] -> std.result(void, errtype))
	pkglocal const bget :		(x : ctx# -> std.option(char))
	pkglocal const bnext :		(x : ctx# -> char)
	pkglocal const beatspace :	(x : ctx# -> void)
	pkglocal const beatchar : 	(x : ctx#, c : char -> void)
	pkglocal const bskip :		(x : ctx#, n : int -> void)

	pkglocal const getname :	(x : ctx# -> std.result((std.size, std.size), errtype))

	type refill = union
		`Done
		`Fail	errtype
		`Empty
	;;
;;

/* replace the ctx buffer with the provided buf and reset the idx */
const newbuf = {x, buf
	std.slfree(x.p.buf)
	x.p.bidx = 0
	x.p.buf = buf
}

/* extend the ctx buffer with more file bytes up to the next > character */
const refillbuf = {x
	match bio.readterm(x.file, ">")
	| `std.Ok b:
		x.p.buf = std.sljoin(&x.p.buf, b)
		std.slfree(b)
		-> `Done
	| `std.Err `bio.Eof:	-> `Empty
	| `std.Err e:		-> `Fail `Trunc e
	;;
}

/* check if the head of the ctx buffer is the given string */
const bexpect = {x, want
	var nidx

	nidx = x.p.bidx + want.len
	if nidx <= x.p.buf.len && std.sleq(x.p.buf[x.p.bidx:nidx], want)
		x.p.bidx = nidx
	else
		/* figure out what the error was */
		for w : std.bychar(want)
			match bget(x)
			| `std.Some c:
				if c != w
					-> `std.Err `Unexpected (c, w)
				;;
			| `std.None:	-> `std.Err `Trunc `bio.Eof
			;;
		;;
		/* the condition shouldn't have failed if this is reached */
		std.die("BUG: bexpect() match failed but no error found\n")
	;;

	-> `std.Ok void
}

/* take the next character from the ctx buffer if possible */
const bget = {x
	if x.p.bidx < x.p.buf.len
		-> `std.Some bnext(x)
	else
		-> `std.None
	;;
}

/* take the next character from the ctx buffer, the idx must be in range */
const bnext = {x
	var c

	c = std.decode(x.p.buf[x.p.bidx:])
	x.p.bidx += std.charlen(c)

	match c
	| '\n':
		x.p.line++
		x.p.off = 0
	| _:
		x.p.off++
	;;

	-> c
}

/* skips all xml whitespace at the head of the ctx buffer XXX FIXME */
const beatspace = {x
	var p
	while true
		p = std.decode(x.p.buf[x.p.bidx:])
		match p
		| ' ':
		| '\n':
			x.p.line++
			x.p.off = 0
			goto next
		| '\t':
		| '\r':
		| _:
			break
		;;
		x.p.off++
:next
		x.p.bidx += std.charlen(p)
	;;
}

/* the head of the ctx buffer is moved as if the given char was taken */
const beatchar = {x, c
	x.p.bidx += std.charlen(c)
	x.p.off++
}

/* skips n chars from the front of the ctx buffer */
const bskip = {x, n
	for var i = 0; i < n; i++
		bnext(x)
	;;
}

/* gets an xml name from the head of the ctx buffer if possible */
const getname = {x
	var c
	var start

	if x.p.bidx >= x.p.buf.len
		-> `std.Err `Trunc `bio.Eof
	;;

	start = x.p.bidx
	c = bnext(x)
	if !namestartchar(c)
		-> `std.Err `Inval c
	;;

	while x.p.bidx < x.p.buf.len
		c = std.decode(x.p.buf[x.p.bidx:])
		if namechar(c)
			x.p.off++
			x.p.bidx += std.charlen(c)
		else
			break
		;;
	;;

	-> `std.Ok (start, x.p.bidx)
}
