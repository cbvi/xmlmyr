use std
use bio

use "buf"
use "chars"
use "err"
use "types"

pkg xml =
	pkglocal const parseattrs : (x : ctx# -> std.result(std.size, err))
;;

const parseattrs = {x
	var name, val
	var err
	var cnt = 0

	beatspace(x)

	while x.p.bidx < x.p.buf.len
		match std.decode(x.p.buf[x.p.bidx:])
		| '>':	goto done
		| '/':	goto done
		| _:
		;;

		match parseattrname(x)
		| `std.Ok n:	name = n
		| `std.Err e:
			err = e
			goto err
		;;

		beatspace(x)

		match parseattrval(x)
		| `std.Ok v:	val = v
		| `std.Err e:
			err = e
			goto err
		;;

		if cnt >= x.a.offs.len
			x.a.offs = std.slgrow(&x.a.offs, 2 * x.a.offs.len)
		;;

		x.a.offs[cnt] = (name, val)
		cnt++

		if x.p.bidx < x.p.buf.len
			match std.decode(x.p.buf[x.p.bidx:])
			| '>':	goto done
			| '/':	goto done
			| c:
				if isspace(c)
					beatspace(x)
				else
					err = error(x, `Inval c)
					goto err
				;;
			;;
		else
			break
		;;
	;;

	err = error(x, `Trunc `bio.Eof)
	goto err

:done
	if x.a.attrs.len < x.a.offs.len
		x.a.attrs = std.slgrow(&x.a.attrs, x.a.offs.len)
	;;

	for var i = 0; i < cnt; i++
		match x.a.offs[i]
		| ((ns, ne), (vs, ve)):
			x.a.attrs[i] = (x.p.buf[ns:ne], x.p.buf[vs:ve])
		;;
	;;
	-> `std.Ok cnt

:err
	-> `std.Err err
}

const parseattrname = {x
	var start, stop

	match getname(x)
	| `std.Ok o:	(start, stop) = o
	| `std.Err e:	-> `std.Err error(x, e)
	;;

	match bget(x)
	| `std.Some '=':	-> `std.Ok (start, stop)
	| `std.Some c:
		if !isspace(c)
			-> `std.Err error(x, `Inval c)
		;;
	| `std.None:	-> `std.Err error(x, `Trunc `bio.Eof)
	;;

	beatspace(x)

	match bexpect(x, '=')
	| `std.Ok _:	-> `std.Ok (start, stop)
	| `std.Err e:	-> `std.Err error(x, e)
	;;
}

const parseattrval = {x
	var start
	var q

	match bget(x)
	| `std.Some '"':	q = '"'
	| `std.Some '\'':	q = '\''
	| `std.Some c:		-> `std.Err error(x, `Unexpected (c, '"'))
	| `std.None:		-> `std.Err error(x, `Trunc `bio.Eof)
	;;

	start = x.p.bidx

:again
	while x.p.bidx < x.p.buf.len
		if bnext(x) == q
			-> `std.Ok (start, x.p.bidx-std.charlen(q))
		;;
	;;

	match bio.readterm(x.file, ">")
	| `std.Ok s:	expandbuf(x, s)
	| `std.Err e:	-> `std.Err error(x, `Trunc e)
	;;

	goto again
}
