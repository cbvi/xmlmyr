use std
use bio

use "buf"
use "chars"
use "err"
use "types"

pkg xml =
	pkglocal const parseattrs : (x : ctx#, attrs : (byte[:], byte[:])[:]# -> std.result(void, err))
;;

const parseattrs = {x, attrs
	var name, val
	var offs = [][:]
	var err

	beatspace(x)

	while x.p.bidx < x.p.buf.len
		match bpeek(x)
		| '>':	goto done
		| '/':	goto done
		| _:
		;;

		match parseattrname(x)
		| `std.Ok n:	name = n
		| `std.Err e:
			err = e
			goto err
		;;

		match parseattrval(x)
		| `std.Ok v:	val = v
		| `std.Err e:
			err = e
			goto err
		;;

		std.slpush(&offs, (name, val))

		if x.p.bidx < x.p.buf.len
			match bpeek(x)
			| '>':	goto done
			| '/':	goto done
			| c:
				if isspace(c)
					beatspace(x)
				else
					err = error(x, `Inval c)
					goto err
				;;
			;;
		else
			break
		;;
	;;

	err = error(x, `Trunc `bio.Eof)
	goto err

:done
	for off : offs
		match off
		| ((ns, ne), (vs, ve)):
			std.slpush(attrs, (x.p.buf[ns:ne], x.p.buf[vs:ve]))
		;;
	;;
	std.slfree(offs)
	-> `std.Ok void

:err
	std.slfree(offs)
	-> `std.Err err
}

const parseattrname = {x
	var start, stop

	beatspace(x)

	match startname(x)
	| `std.Ok o:	(start, stop) = o
	| `std.Err e:	-> `std.Err e
	;;

	while x.p.bidx < x.p.buf.len
		match bnext(x)
		| '=':	goto end
		| c:
			if namechar(c)
				stop = x.p.bidx
			elif isspace(c)
				beatspace(x)
				goto ending
			else
				-> `std.Err error(x, `Inval c)
			;;
		;;
	;;

	goto eof

:ending
	if x.p.bidx < x.p.buf.len
		match bnext(x)
		| '=':	/* fallthrough to end */
		| c:	-> `std.Err error(x, `Unexpected (c, '='))
		;;
	else
		goto eof
	;;

:end
	-> `std.Ok (start, stop)

:eof
	-> `std.Err error(x, `Trunc `bio.Eof)
}

const parseattrval = {x
	var start, stop
	var q

	beatspace(x)

	match bnext(x)
	| '"':	q = '"'
	| '\'':	q = '\''
	| c:	-> `std.Err error(x, `Unexpected (c, '"'))
	;;

	start = x.p.bidx

	while true
		while x.p.bidx < x.p.buf.len
			stop = x.p.bidx
			if bnext(x) == q
				-> `std.Ok (start, stop)
			;;
		;;

		match bio.readterm(x.file, ">")
		| `std.Ok s:	expandbuf(x, s)
		| `std.Err e:	-> `std.Err error(x, `Trunc e)
		;;
	;;
	std.die("unreached\n")
}
