use std
use bio

use "buf"
use "chars"
use "err"
use "types"

pkg xml =
	pkglocal const parseattrs : (x : ctx# -> std.result(std.size, err))
;;

const parseattrs = {x
	var name, val
	var err
	var cnt = 0

	beatspace(x)

	while x.p.bidx < x.p.buf.len
		match bpeek(x)
		| '>':	goto done
		| '/':	goto done
		| _:
		;;

		match parseattrname(x)
		| `std.Ok n:	name = n
		| `std.Err e:
			err = e
			goto err
		;;

		match parseattrval(x)
		| `std.Ok v:	val = v
		| `std.Err e:
			err = e
			goto err
		;;

		if cnt >= x.a.offs.len
			x.a.offs = std.slgrow(&x.a.offs, 2 * x.a.offs.len)
		;;

		x.a.offs[cnt] = (name, val)
		cnt++

		if x.p.bidx < x.p.buf.len
			match bpeek(x)
			| '>':	goto done
			| '/':	goto done
			| c:
				if isspace(c)
					beatspace(x)
				else
					err = error(x, `Inval c)
					goto err
				;;
			;;
		else
			break
		;;
	;;

	err = error(x, `Trunc `bio.Eof)
	goto err

:done
	if x.a.attrs.len < x.a.offs.len
		x.a.attrs = std.slgrow(&x.a.attrs, x.a.offs.len)
	;;

	for var i = 0; i < cnt; i++
		match x.a.offs[i]
		| ((ns, ne), (vs, ve)):
			x.a.attrs[i] = (x.p.buf[ns:ne], x.p.buf[vs:ve])
		;;
	;;
	-> `std.Ok cnt

:err
	-> `std.Err err
}

const parseattrname = {x
	var start, stop

	beatspace(x)

	match startname(x)
	| `std.Ok o:	(start, stop) = o
	| `std.Err e:	-> `std.Err e
	;;

	while x.p.bidx < x.p.buf.len
		match bnext(x)
		| '=':	goto end
		| c:
			if namechar(c)
				stop = x.p.bidx
			elif isspace(c)
				beatspace(x)
				goto ending
			else
				-> `std.Err error(x, `Inval c)
			;;
		;;
	;;

	goto eof

:ending
	if x.p.bidx < x.p.buf.len
		match bnext(x)
		| '=':	/* fallthrough to end */
		| c:	-> `std.Err error(x, `Unexpected (c, '='))
		;;
	else
		goto eof
	;;

:end
	-> `std.Ok (start, stop)

:eof
	-> `std.Err error(x, `Trunc `bio.Eof)
}

const parseattrval = {x
	var start, stop
	var q

	beatspace(x)

	match bnext(x)
	| '"':	q = '"'
	| '\'':	q = '\''
	| c:	-> `std.Err error(x, `Unexpected (c, '"'))
	;;

	start = x.p.bidx

	while true
		while x.p.bidx < x.p.buf.len
			stop = x.p.bidx
			if bnext(x) == q
				-> `std.Ok (start, stop)
			;;
		;;

		match bio.readterm(x.file, ">")
		| `std.Ok s:	expandbuf(x, s)
		| `std.Err e:	-> `std.Err error(x, `Trunc e)
		;;
	;;
	std.die("unreached\n")
}
