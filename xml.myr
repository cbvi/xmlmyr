use std
use bio

use "chars"
use "types"

pkg xml =
	const mkbuf	:	(s : byte[:] -> xmlctx#)
	const mkfile	:	(f : bio.file# -> xmlctx#)
	const byevent	:	(x : xmlctx# -> xmlctx)
	const free 	:	(x : xmlctx# -> void)

	impl iterable xmlctx -> std.result(event, error)
;;

impl iterable xmlctx -> std.result(event, error) =
	__iternext__ = {iterp, valp
		if iterp.error
			-> false
		;;

		valp# = dispatch(iterp)
		if iterp.more
			-> true
		else
			-> false
		;;
	}

	__iterfin__ = {iterp, valp
		match valp#
		| `std.Ok `Start (n, a):
			std.slfree(a)
		| _:
		;;
	}
;;

type event = union
	`Instruction	(byte[:], byte[:])
	`Doctype	byte[:]
	`Eof
	`Start		(byte[:], (byte[:], byte[:])[:])
	`End		byte[:]
	`Characters	byte[:]
	`Comment	byte[:]
;;

const dispatch = {x
	match x.state
	| `Open:	-> open(x)
	| `Close:	-> close(x)
	| `Closing n:	-> closing(x, n)
	;;
}

const close = {x
	var start, stop

	x.state = `Open

	match bio.readterm(x.file, "<")
	| `std.Ok s:
		newbuf(x, s)
	| `std.Err `bio.Eof:
		x.more = false
		-> `std.Ok `Eof
	| `std.Err e:
		-> `std.Err error(x, `Trunc e)
	;;

	start = stop = x.bidx

	while x.bidx < x.buf.len
		match bnext(x)
		| '<':
			if std.strstrip(x.buf[start:stop]).len > 0
				/* TODO entities */
				-> `std.Ok `Characters x.buf[start:stop]
			else
				-> dispatch(x)
			;;
		| c:
			stop = x.bidx
		;;
	;;

	if std.strstrip(x.buf).len > 0
		-> `std.Err error(x, `Trunc `bio.Eof)
	else
		x.more = false
		-> `std.Ok `Eof
	;;
}

const open = {x
	x.state = `Close

	match bio.peekc(x.file)
	| `std.Ok '!':	-> parseexclamation(x)
	| `std.Ok '/':	-> parseend(x)
	| `std.Ok '?':	-> parseinstruction(x)
	| `std.Ok '>':	-> `std.Err error(x, `Empty)
	| `std.Ok _:	-> parseelemname(x)
	| `std.Err `bio.Eof:
		x.more = false
		-> `std.Ok `Eof
	| `std.Err e:	-> `std.Err error(x, `Trunc e)
	;;
}

const closing = {x, name
	x.state = `Close

	match bnext(x)
	| '>':	-> `std.Ok `End name
	| c:	-> `std.Err error(x, `Unexpected (c, '>'))
	;;
}

const parseelemname = {x
	var start, stop
	var attrs = [][:]
	var ex = false

	match bio.readterm(x.file, ">")
	| `std.Ok s:	newbuf(x, s)
	| `std.Err e:	-> `std.Err error(x, `Trunc e)
	;;

	match bnext(x)
	| '>':	-> `std.Err error(x, `Empty)
	| '/':	-> `std.Err error(x, `Empty)
	| c:
		if namestartchar(c)
			start =  x.bcur
			stop = x.bidx
		else
			-> `std.Err error(x, `Inval c)
		;;
	;;

	while x.bidx < x.buf.len
		match bnext(x)
		| '>':
			-> `std.Ok `Start (x.buf[start:stop], attrs)
		| '/':
			if x.buf[start:stop].len > 0
				x.state = `Closing x.buf[start:stop]
				-> `std.Ok `Start (x.buf[start:stop], attrs)
			else
				-> `std.Err error(x, `Empty)
			;;
		| c:
			if ex
				-> `std.Err error(x, `Unexpected (c, '>'))
			elif namechar(c)
				stop = x.bidx
			elif isspace(c)
				match parseattrs(x, &attrs)
				| `std.Ok _:
					ex = true
				| `std.Err e:
					std.slfree(attrs)
					-> `std.Err e
				;;
			else
				-> `std.Err error(x, `Inval c)
			;;
		;;
	;;

	-> `std.Err error(x, `Trunc `bio.Eof)
}

const parseexclamation = {x
	std.assert(std.try(bio.getc(x.file)) == '!', "! not found")
	x.off++

	match bio.peekc(x.file)
	| `std.Ok '[':	-> parsecdata(x)
	| `std.Ok '-':	-> parsecomment(x)
	| `std.Ok 'D':	-> parsedoctype(x)
	| `std.Ok c:	-> `std.Err error(x, `Junk c)
	| `std.Err e:	-> `std.Err error(x, `Trunc e)
	;;
}

const parseend = {x
	var start, stop
	var spaced = false

	match bio.readterm(x.file, ">")
	| `std.Ok s:	newbuf(x, s)
	| `std.Err e:	-> `std.Err error(x, `Trunc e)
	;;

	std.assert(bnext(x) == '/', "/ not found")

	match bnext(x)
	| c:
		if namestartchar(c)
			start = x.bcur
			stop = x.bidx
		else
			-> `std.Err error(x, `Inval c)
		;;
	;;

	while x.bidx < x.buf.len
		match bnext(x)
		| '>':
			-> `std.Ok `End x.buf[start:stop]
		| c:
			if isspace(c)
				spaced = true
				eatspace(x)
			elif !spaced && namechar(c)
				stop = x.bidx
			else
				-> `std.Err error(x, `Inval c)
			;;
		;;
	;;

	-> `std.Err error(x, `Trunc `bio.Eof)
}

const parseattrs = {x, attrs
	var name, val

	eatspace(x)

	while x.bidx < x.buf.len
		match bpeek(x)
		| '>':	-> `std.Ok void
		| '/':	-> `std.Ok void
		| _:
		;;

		match parseattrname(x)
		| `std.Ok n:	name = n
		| `std.Err e:	-> `std.Err e
		;;

		match parseattrval(x)
		| `std.Ok v:	val = v
		| `std.Err e:	-> `std.Err e
		;;

		std.slpush(attrs, (name, val))

		eatspace(x)
	;;

	-> `std.Err error(x, `Trunc `bio.Eof)
}

const parseattrname = {x
	var start, stop
	var spaced = false

	eatspace(x)

	match bnext(x)
	| c:
		if namestartchar(c)
			start =  x.bcur
			stop = x.bidx
		else
			-> `std.Err error(x, `Inval c)
		;;
	;;

	while x.bidx < x.buf.len
		match bnext(x)
		| '=':	-> `std.Ok x.buf[start:stop]
		| c:
			if spaced
				-> `std.Err error(x, `Unexpected (c, '='))
			elif namechar(c)
				stop = x.bidx
			elif isspace(c)
				spaced = true
				eatspace(x)
			else
				-> `std.Err error(x, `Inval c)
			;;
		;;
	;;

	-> `std.Err error(x, `Trunc `bio.Eof)
}

const parseattrval = {x
	var start, stop
	var q

	eatspace(x)

	match bnext(x)
	| '"':	q = '"'
	| '\'':	q = '\''
	| c:	-> `std.Err error(x, `Unexpected (c, '"'))
	;;

	start = stop = x.bidx

	while x.bidx < x.buf.len
		if bnext(x) == q
			-> `std.Ok x.buf[start:stop]
		else
			stop = x.bidx
		;;
	;;

	-> `std.Err error(x, `Trunc `bio.Eof)
}

const prefixtoterm = {x, pref, suf
	match bio.readterm(x.file, suf)
	| `std.Ok s:	newbuf(x, s)
	| `std.Err e:	-> `std.Err error(x, `Trunc e)
	;;


	for cc : std.bychar(pref)
		match bnext(x)
		| c:	if c != cc && (cc == ' ' && !isspace(c))
				-> `std.Err error(x, `Unexpected (c, cc))
			;;
		;;
	;;

	taste(x)

	if std.hassuffix(x.buf, suf) && x.bidx < x.buf.len
		-> `std.Ok x.buf[x.bidx:x.buf.len-suf.len]
	else
		-> `std.Err error(x, `Trunc `bio.Eof)
	;;
}

const parsecdata = {x
	match prefixtoterm(x, "[CDATA[", "]]>")
	| `std.Ok b:	-> `std.Ok `Characters b
	| `std.Err e:	-> `std.Err e
	;;
}

const parsecomment = {x
	match prefixtoterm(x, "--", "-->")
	| `std.Ok b:	-> `std.Ok `Comment b
	| `std.Err e:	-> `std.Err e
	;;
}

const parsedoctype = {x
	match prefixtoterm(x, "DOCTYPE ", ">")
	| `std.Ok b:	-> `std.Ok `Doctype std.strstrip(b)
	| `std.Err e:	-> `std.Err e
	;;
}

const parseinstruction = {x
	var start, stop

	match prefixtoterm(x, "?", "?>")
	| `std.Ok b:	newbuf(x, std.sldup(b))
	| `std.Err e:	-> `std.Err error(x, `Trunc `bio.Eof)
	;;

	if x.bidx < x.buf.len
		match bnext(x)
		| c:	if namestartchar(c)
				start = x.bcur
				stop = x.bidx
			else
				-> `std.Err error(x, `Inval c)
			;;
		;;
	else
		-> `std.Err error(x, `Trunc `bio.Eof)
	;;

	while x.bidx < x.buf.len
		match bnext(x)
		| c:	if namechar(c)
				stop = x.bidx
			elif isspace(c)
				eatspace(x)
				break
			else
				-> `std.Err error(x, `Inval c)
			;;
		;;
	;;

	-> `std.Ok `Instruction (x.buf[start:stop], x.buf[x.bidx:])
}

const bpeek = {x
	if x.bidx < x.buf.len
		-> std.decode(x.buf[x.bidx:])
	else
		-> std.Badchar
	;;
}

const bnext = {x
	if x.bidx >= x.buf.len
		-> std.Badchar
	;;

	var c = std.decode(x.buf[x.bidx:])
	x.bcur = x.bidx
	x.bidx += std.charlen(c)

	if c == '\n'
		x.line++
		x.off = 0
	else
		x.off++
	;;

	-> c
}

const newbuf = {x, buf
	std.slfree(x.buf)
	x.bidx = x.bcur = 0
	x.buf = buf
}

const eatspace = {x
	while true
		match bpeek(x)
		| ' ':
		| '\n':
		| '\t':
		| '\r':
		| _:	break
		;;

		bnext(x)
	;;
}

const taste = {x
	for c : std.bychar(x.buf[x.bidx:])
		if c == '\n'
			x.line++
			x.off = 0
		else
			x.off++
		;;
	;;
}

/* like bio.skipspace but includes \r and increments the offsets */
const skipspace = {x
	while true
		match bio.peekc(x.file)
		| `std.Ok ' ':
		| `std.Ok '\n':
			x.line++
			x.off = 0
			goto nl
		| `std.Ok '\t':
		| `std.Ok '\r':
		| `std.Ok _:
			break
		| `std.Err _:
			break
		;;

		x.off++
:nl
		bio.getc(x.file)
	;;
}

const error = {x, e
	x.error = true
	-> [.line = x.line, .off = x.off, .err = e]
}

const free = {x
	bio.close(x.file)
	std.slfree(x.buf)
	std.free(x)
}

const mkbuf = {s
	var x = std.mk([
		.file = bio.mkmem(s),
		.buf = [][:],
		.bidx = 0,
		.bcur = 0,
		.line = 1,
		.off = 0,
		.state = `Close,
		.more = true,
		.error = false
	])

	skipspace(x)

	-> x
}

const mkfile = {f
	var x = std.mk([
		.file = f,
		.buf = [][:],
		.bidx = 0,
		.bcur = 0,
		.line = 1,
		.off = 0,
		.state = `Close,
		.more = true,
		.error = false
	])

	skipspace(x)

	-> x
}

const byevent = {x
	-> x#
}
