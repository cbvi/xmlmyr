use std
use bio

use "attributes"
use "buf"
use "chars"
use "doctype"
use "err"
use "mk"
use "types"

pkg xml =
	pkglocal const dispatch	: (x : ctx# -> std.result(event, errtype))
;;

const dispatch = {x
	match x.p.state
	| `Open:	-> open(x)
	| `Close:	-> close(x)
	| `Closing n:	-> closing(x, n)
	;;
}

const close = {x
	var start, stop

	match bio.readterm(x.file, "<")
	| `std.Ok s:	newbuf(x, s)
	| `std.Err `bio.Eof:
		x.p.more = false
		-> `std.Ok `Eof
	| `std.Err e:	-> `std.Err `Trunc e
	;;

	start = x.p.bidx

	while x.p.bidx < x.p.buf.len
		if bnext(x) == '<'
			x.p.state = `Open
			stop = x.p.bidx - std.charlen('<')
			if prune(x.p.buf[start:stop]).len > 0
				-> `std.Ok `Characters x.p.buf[start:stop]
			else
				-> dispatch(x)
			;;
		;;
	;;

	if prune(x.p.buf).len > 0
		-> `std.Ok `Characters x.p.buf[start:x.p.bidx]
	else
		x.p.more = false
		-> `std.Ok `Eof
	;;
}

const open = {x
	x.p.state = `Close

	match bio.peekc(x.file)
	| `std.Ok '!':	-> parseexclamation(x)
	| `std.Ok '/':	-> parseend(x)
	| `std.Ok '?':	-> parseinstruction(x)
	| `std.Ok _:	-> parseelemname(x)
	| `std.Err e:	-> `std.Err `Trunc e
	;;
}

const closing = {x, name
	x.p.state = `Close
	-> `std.Ok `End name
}

const parseelemname = {x
	var start, stop
	var cnt = 0

	match bio.readterm(x.file, ">")
	| `std.Ok s:	newbuf(x, s)
	| `std.Err e:	-> `std.Err `Trunc e
	;;

	match getname(x)
	| `std.Ok o:			(start, stop) = o
	| `std.Err `Trunc `bio.Eof:	goto unclosed
	| `std.Err e:			-> `std.Err e
	;;

	match bget(x)
	| `std.Some '>':	goto end
	| `std.Some '/':	goto selfclose
	| `std.Some c:
		if !isspace(c)
			-> `std.Err `Inval c
		;;
		/* fallthrough to parseattrs */
	| `std.None:	goto unclosed
	;;

	match parseattrs(x)
	| `std.Ok i:	cnt = i
	| `std.Err e:	-> `std.Err e
	;;

	match bget(x)
	| `std.Some '>':	/* fallthrough to end */
	| `std.Some '/':	goto selfclose
	| `std.Some c:		-> `std.Err `Unexpected (c, '>')
	| `std.None:		goto unclosed
	;;

:end
	-> `std.Ok `Start (x.p.buf[start:stop], x.a.attrs[:cnt])

:selfclose
	match bget(x)
	| `std.Some '>':
		x.p.state = `Closing x.p.buf[start:stop]
		-> `std.Ok `Start (x.p.buf[start:stop], x.a.attrs[:cnt])
	| `std.Some c:	-> `std.Err `Unexpected (c, '>')
	| `std.None:	-> `std.Err `Unclosed ("<", "/>")
	;;

:unclosed
	-> `std.Err `Unclosed ("<", ">")
}

const parseexclamation = {x
	match bio.getc(x.file)
	| `std.Ok c:
		std.assert(c == '!', "BUG: parseexclamation() ! missing\n")
		x.p.off++
	| `std.Err e:	-> `std.Err `Trunc e
	;;

	match bio.peekc(x.file)
	| `std.Ok '[':	-> parsecdata(x)
	| `std.Ok '-':	-> parsecomment(x)
	| `std.Ok 'D':	-> parsedoctype(x)
	| `std.Ok c:	-> `std.Err `Inval c
	| `std.Err e:	-> `std.Err `Trunc e
	;;
}

const parseend = {x
	var start, stop

	match bio.readterm(x.file, ">")
	| `std.Ok s:	newbuf(x, s)
	| `std.Err e:	-> `std.Err `Trunc e
	;;

	/* to get here peek has to show a / was next up */
	std.assert(bnext(x) == '/', "BUG: parseend() / missing\n")

	match getname(x)
	| `std.Ok o:			(start, stop) = o
	| `std.Err `Trunc `bio.Eof:	goto unclosed
	| `std.Err e:			-> `std.Err e
	;;

	beatspace(x)

	match bget(x)
	| `std.Some '>':	-> `std.Ok `End x.p.buf[start:stop]
	| `std.Some c:		-> `std.Err `Unexpected (c, '>')
	| `std.None:		goto unclosed
	;;

:unclosed
	-> `std.Err `Unclosed ("</", ">")
}

const parsecdata = {x
	const pre = "[CDATA["
	const suf = "]]>"
	var st
	var end

	match bio.readterm(x.file, ">")
	| `std.Ok b:	newbuf(x, b)
	| `std.Err e:	-> `std.Err `Trunc e
	;;

	match bexpect(x, pre)
	| `std.Ok _:	x.p.off += 7
	| `std.Err e:	-> `std.Err e
	;;

	st = x.p.bidx
	end = 0

:again
	while x.p.bidx < x.p.buf.len
		match bnext(x)
		| ']':	end++
		| '>':	if end > 1
				-> `std.Ok `Cdata x.p.buf[st:x.p.bidx-suf.len]
			;;
		| _:	end = 0
		;;
	;;

	match bio.readterm(x.file, ">")
	| `std.Ok b:	expandbuf(x, b)
	| `std.Err `bio.Eof:
			-> `std.Err `Unclosed ("<![CDATA[", "]]>")
	| `std.Err e:	-> `std.Err `Trunc e
	;;

	goto again
}

const parsecomment = {x
	const suf = "-->"
	var c, end
	var st

	match bio.readterm(x.file, ">")
	| `std.Ok b:	newbuf(x, b)
	| `std.Err e:	-> `std.Err `Trunc e
	;;

	match bexpect(x, "--")
	| `std.Ok _:	x.p.off += 2
	| `std.Err e:	-> `std.Err e
	;;

	end = 0
	st = x.p.bidx

:again
	while x.p.bidx < x.p.buf.len
		c = bnext(x)

		if end == 2
			if c != '>'
				/* stray -- in comments is invalid */
				-> `std.Err `Unexpected (c, '>')
			;;
			-> `std.Ok `Comment prune(x.p.buf[st:x.p.bidx-suf.len])
		elif c == '-'
			end++
		else
			end = 0
		;;
	;;

	match bio.readterm(x.file, ">")
	| `std.Ok b:	expandbuf(x, b)
	| `std.Err `bio.Eof:
			-> `std.Err `Unclosed ("<!--", "-->")
	| `std.Err e:	-> `std.Err `Trunc e
	;;

	goto again
}

const parseinstruction = {x
	const suf = "?>"
	var ts, te
	var ds
	var end
	var err

	match bio.readterm(x.file, ">")
	| `std.Ok b:	newbuf(x, b)
	| `std.Err e:	err = `Trunc e ; goto err
	;;

	/* to get here peek has to show a ? was next up */
	std.assert(bnext(x) == '?', "BUG: parseinstruction() '?' missing\n")

	match getname(x)
	| `std.Ok o:	(ts, te) = o
	| `std.Err e:	-> `std.Err e
	;;

	match bget(x)
	| `std.Some '?':
		match bget(x)
		| `std.Some '>': -> `std.Ok `Instruction (x.p.buf[ts:te], "")
		| `std.Some c:	 -> `std.Err `Unexpected (c, '>')
		| `std.None:	 goto unclosed
		;;
	| `std.Some c:
		if isspace(c)
			beatspace(x)
		else
			err = `Inval c ; goto err
		;;
	| `std.None:
		goto unclosed
	;;

	end = false
	ds = x.p.bidx

:again
	while x.p.bidx < x.p.buf.len
		match bnext(x)
		| '?':	end = true
		| '>':	if end
				-> `std.Ok `Instruction (x.p.buf[ts:te],
					x.p.buf[ds:x.p.bidx-suf.len])
			;;
		| _:	end = false
		;;
	;;

	match bio.readterm(x.file, ">")
	| `std.Ok b:		expandbuf(x, b)
	| `std.Err `bio.Eof:	goto unclosed
	| `std.Err e:		err = `Trunc e ; goto err
	;;

	goto again

:unclosed
	err = `Unclosed ("<?", "?>")

:err
	-> `std.Err err
}
