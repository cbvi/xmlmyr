use std
use bio

use "attributes"
use "buf"
use "chars"
use "doctype"
use "err"
use "mk"
use "types"

pkg xml =
	pkglocal const dispatch	: (x : ctx# -> std.result(event, err))
;;

const dispatch = {x
	match x.p.state
	| `Open:	-> open(x)
	| `Close:	-> close(x)
	| `Closing n:	-> closing(x, n)
	;;
}

const close = {x
	var start, stop

	match bio.readterm(x.file, "<")
	| `std.Ok s:
		newbuf(x, s)
	| `std.Err `bio.Eof:
		x.p.more = false
		-> `std.Ok `Eof
	| `std.Err e:
		-> `std.Err error(x, `Trunc e)
	;;

	start = x.p.bidx

	while x.p.bidx < x.p.buf.len
		if bnext(x) == '<'
			stop = x.p.bcur
			x.p.state = `Open
			if prune(x.p.buf[start:stop]).len > 0
				-> `std.Ok `Characters x.p.buf[start:stop]
			else
				-> dispatch(x)
			;;
		;;
	;;

	stop = x.p.bidx

	if prune(x.p.buf).len > 0
		-> `std.Ok `Characters x.p.buf[start:stop]
	else
		x.p.more = false
		-> `std.Ok `Eof
	;;
}

const open = {x
	x.p.state = `Close

	match bio.peekc(x.file)
	| `std.Ok '!':	-> parseexclamation(x)
	| `std.Ok '/':	-> parseend(x)
	| `std.Ok '?':	-> parseinstruction(x)
	| `std.Ok _:	-> parseelemname(x)
	| `std.Err e:	-> `std.Err error(x, `Trunc e)
	;;
}

const closing = {x, name
	x.p.state = `Close
	-> `std.Ok `End name
}

const parseelemname = {x
	var start, stop
	var attrs = [][:]

	match bio.readterm(x.file, ">")
	| `std.Ok s:	newbuf(x, s)
	| `std.Err e:	-> `std.Err error(x, `Trunc e)
	;;

	match startname(x)
	| `std.Ok o:	(start, stop) = o
	| `std.Err e:	-> `std.Err e
	;;

	while x.p.bidx < x.p.buf.len
		match bnext(x)
		| '>':
			stop = x.p.bcur
			goto end
		| '/':
			stop = x.p.bcur
			goto selfclose
		| c:
			if namechar(c)
				continue
			elif isspace(c)
				stop = x.p.bcur
				goto attrs
			else
				-> `std.Err error(x, `Inval c)
			;;
		;;
	;;

	goto unclosed

:attrs
	match parseattrs(x, &attrs)
	| `std.Ok _:
	| `std.Err e:
		std.slfree(attrs)
		-> `std.Err e
	;;

:ending
	if x.p.bidx < x.p.buf.len
		match bnext(x)
		| '/':	goto selfclose
		| '>':	/* fallthrough to end */
		| c:
			std.slfree(attrs)
			-> `std.Err error(x, `Unexpected (c, '>'))
		;;
	else
		goto unclosed
	;;

:end
	-> `std.Ok `Start (x.p.buf[start:stop], attrs)

:selfclose
	-> parseselfclose(x, x.p.buf[start:stop], attrs)

:unclosed
	std.slfree(attrs)
	-> `std.Err error(x, `Unclosed ("<", ">"))
}

const parseexclamation = {x
	match bio.getc(x.file)
	| `std.Ok c:
		std.assert(c == '!', "BUG: parseexclamation() ! missing\n")
		x.p.off++
	| `std.Err e:	-> `std.Err error(x, `Trunc e)
	;;

	match bio.peekc(x.file)
	| `std.Ok '[':	-> parsecdata(x)
	| `std.Ok '-':	-> parsecomment(x)
	| `std.Ok 'D':	-> parsedoctype(x)
	| `std.Ok c:	-> `std.Err error(x, `Inval c)
	| `std.Err e:	-> `std.Err error(x, `Trunc e)
	;;
}

const parseend = {x
	var start, stop

	match bio.readterm(x.file, ">")
	| `std.Ok s:	newbuf(x, s)
	| `std.Err e:	-> `std.Err error(x, `Trunc e)
	;;

	std.assert(bnext(x) == '/', "BUG: parseend() / missing\n")

	match startname(x)
	| `std.Ok o:	(start, stop) = o
	| `std.Err [.line=_, .off=_, .err=`Trunc `bio.Eof]:
		goto unclosed
	| `std.Err e:	-> `std.Err e
	;;

	while x.p.bidx < x.p.buf.len
		match bnext(x)
		| '>':
			stop = x.p.bcur
			goto end
		| c:
			if namechar(c)
				continue
			elif isspace(c)
				stop = x.p.bcur
				beatspace(x)
				goto ending
			else
				-> `std.Err error(x, `Inval c)
			;;
		;;
	;;

	goto unclosed

:ending
	if x.p.bidx < x.p.buf.len
		match bnext(x)
		| '>':	/* fallthrough to end */
		| c:	-> `std.Err error(x, `Unexpected (c, '>'))
		;;
	else
		goto unclosed
	;;

:end
	-> `std.Ok `End x.p.buf[start:stop]

:unclosed
	-> `std.Err error(x, `Unclosed ("</", ">"))
}

const parseselfclose = {x, name, attrs
	if x.p.bidx < x.p.buf.len
		match bnext(x)
		| '>':
			x.p.state = `Closing name
			-> `std.Ok `Start (name, attrs)
		| c:
			-> `std.Err error(x, `Unexpected (c, '>'))
		;;
	else
		-> `std.Err error(x, `Unclosed ("<", "/>"))
	;;
}

const parsecdata = {x
	match fillbuf(x, "<![CDATA[", "[CDATA[", "]]>")
	| `std.Ok b:	-> `std.Ok `Cdata b
	| `std.Err e:	-> `std.Err e
	;;
}

const parsecomment = {x
	match fillbuf(x, "<!--", "--", "-->")
	| `std.Ok b:	-> `std.Ok `Comment prune(b)
	| `std.Err e:	-> `std.Err e
	;;
}

const parseinstruction = {x
	const suf = "?>"
	var start, stop
	var ts, te

	match bio.getc(x.file)
	| `std.Ok c:
		std.assert(c == '?', "BUG: parseinstruction() ? missing\n")
		x.p.off++
	| `std.Err e:	-> `std.Err error(x, `Trunc e)
	;;

	match bio.readterm(x.file, suf)
	| `std.Ok b:	newbuf(x, b)
	| `std.Err e:	-> `std.Err error(x, `Trunc e)
	;;

	match startname(x)
	| `std.Ok o:	(start, stop) = o
	| `std.Err e:	-> `std.Err e
	;;

	while x.p.bidx < x.p.buf.len - suf.len
		match bnext(x)
		| c:	if namechar(c)
				continue
			elif isspace(c)
				stop = x.p.bcur
				beatspace(x)
				goto namedone
			else
				-> `std.Err error(x, `Inval c)
			;;
		;;
	;;

	stop = x.p.bidx

:namedone
	(ts, te) = (start, stop)
	start = x.p.bidx

	while x.p.bidx < x.p.buf.len - suf.len
		bnext(x)
	;;

	stop = x.p.bidx

	for s : std.bychar(suf)
		if s != bnext(x)
			-> `std.Err error(x, `Unclosed ("<?", "?>"))
		;;
	;;

	-> `std.Ok `Instruction (x.p.buf[ts:te], x.p.buf[start:stop])
}
