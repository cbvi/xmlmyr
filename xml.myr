use std
use bio

use "buf"
use "chars"
use "mk"
use "types"

pkg xml =
	pkglocal const dispatch	: (x : ctx# -> std.result(event, err))

	const geterr	:	(x : ctx# -> std.option(err))
;;

const dispatch = {x
	match x.p.state
	| `Open:	-> open(x)
	| `Close:	-> close(x)
	| `Closing n:	-> closing(x, n)
	;;
}

const close = {x
	var start, stop

	x.p.state = `Open

	match bio.readterm(x.file, "<")
	| `std.Ok s:
		newbuf(x, s)
	| `std.Err `bio.Eof:
		x.p.more = false
		-> `std.Ok `Eof
	| `std.Err e:
		-> `std.Err error(x, `Trunc e)
	;;

	start = stop = x.p.bidx

	while x.p.bidx < x.p.buf.len
		match bnext(x)
		| '<':
			if prune(x.p.buf[start:stop]).len > 0
				-> `std.Ok `Characters x.p.buf[start:stop]
			else
				-> dispatch(x)
			;;
		| c:
			stop = x.p.bidx
		;;
	;;

	if prune(x.p.buf).len > 0
		-> `std.Err error(x, `Trunc `bio.Eof)
	else
		x.p.more = false
		-> `std.Ok `Eof
	;;
}

const open = {x
	x.p.state = `Close

	match bio.peekc(x.file)
	| `std.Ok '!':	-> parseexclamation(x)
	| `std.Ok '/':	-> parseend(x)
	| `std.Ok '?':	-> parseinstruction(x)
	| `std.Ok '>':	-> `std.Err error(x, `Empty)
	| `std.Ok _:	-> parseelemname(x)
	| `std.Err `bio.Eof:
		x.p.more = false
		-> `std.Ok `Eof
	| `std.Err e:	-> `std.Err error(x, `Trunc e)
	;;
}

const closing = {x, name
	x.p.state = `Close

	match bnext(x)
	| '>':	-> `std.Ok `End name
	| c:	-> `std.Err error(x, `Unexpected (c, '>'))
	;;
}

const parseelemname = {x
	var start, stop
	var attrs = [][:]
	var ex = false

	match bio.readterm(x.file, ">")
	| `std.Ok s:	newbuf(x, s)
	| `std.Err e:	-> `std.Err error(x, `Trunc e)
	;;

	match bnext(x)
	| '>':	-> `std.Err error(x, `Empty)
	| '/':	-> `std.Err error(x, `Empty)
	| c:
		if namestartchar(c)
			start =  x.p.bcur
			stop = x.p.bidx
		else
			-> `std.Err error(x, `Inval c)
		;;
	;;

	while x.p.bidx < x.p.buf.len
		match bnext(x)
		| '>':
			-> `std.Ok `Start (x.p.buf[start:stop], attrs)
		| '/':
			if x.p.buf[start:stop].len > 0
				x.p.state = `Closing x.p.buf[start:stop]
				-> `std.Ok `Start (x.p.buf[start:stop], attrs)
			else
				-> `std.Err error(x, `Empty)
			;;
		| c:
			if ex
				-> `std.Err error(x, `Unexpected (c, '>'))
			elif namechar(c)
				stop = x.p.bidx
			elif isspace(c)
				match parseattrs(x, &attrs)
				| `std.Ok _:
					ex = true
				| `std.Err e:
					std.slfree(attrs)
					-> `std.Err e
				;;
			else
				-> `std.Err error(x, `Inval c)
			;;
		;;
	;;

	-> `std.Err error(x, `Unclosed ("<", ">"))
}

const parseexclamation = {x
	std.assert(std.try(bio.getc(x.file)) == '!', "! not found")
	x.p.off++

	match bio.peekc(x.file)
	| `std.Ok '[':	-> parsecdata(x)
	| `std.Ok '-':	-> parsecomment(x)
	| `std.Ok 'D':	-> parsedoctype(x)
	| `std.Ok c:	-> `std.Err error(x, `Inval c)
	| `std.Err e:	-> `std.Err error(x, `Trunc e)
	;;
}

const parseend = {x
	var start, stop
	var spaced = false

	match bio.readterm(x.file, ">")
	| `std.Ok s:	newbuf(x, s)
	| `std.Err e:	-> `std.Err error(x, `Trunc e)
	;;

	std.assert(bnext(x) == '/', "/ not found")

	match bnext(x)
	| c:
		if namestartchar(c)
			start = x.p.bcur
			stop = x.p.bidx
		else
			-> `std.Err error(x, `Inval c)
		;;
	;;

	while x.p.bidx < x.p.buf.len
		match bnext(x)
		| '>':
			-> `std.Ok `End x.p.buf[start:stop]
		| c:
			if isspace(c)
				spaced = true
				beatspace(x)
			elif !spaced && namechar(c)
				stop = x.p.bidx
			else
				-> `std.Err error(x, `Inval c)
			;;
		;;
	;;

	-> `std.Err error(x, `Unclosed ("</", ">"))
}

const parseattrs = {x, attrs
	var name, val

	beatspace(x)

	while x.p.bidx < x.p.buf.len
		match bpeek(x)
		| '>':	-> `std.Ok void
		| '/':	-> `std.Ok void
		| _:
		;;

		match parseattrname(x)
		| `std.Ok n:	name = n
		| `std.Err e:	-> `std.Err e
		;;

		match parseattrval(x)
		| `std.Ok v:	val = v
		| `std.Err e:	-> `std.Err e
		;;

		std.slpush(attrs, (name, val))

		beatspace(x)
	;;

	-> `std.Err error(x, `Trunc `bio.Eof)
}

const parseattrname = {x
	var start, stop
	var spaced = false

	beatspace(x)

	match bnext(x)
	| c:
		if namestartchar(c)
			start =  x.p.bcur
			stop = x.p.bidx
		else
			-> `std.Err error(x, `Inval c)
		;;
	;;

	while x.p.bidx < x.p.buf.len
		match bnext(x)
		| '=':	-> `std.Ok x.p.buf[start:stop]
		| c:
			if spaced
				-> `std.Err error(x, `Unexpected (c, '='))
			elif namechar(c)
				stop = x.p.bidx
			elif isspace(c)
				spaced = true
				beatspace(x)
			else
				-> `std.Err error(x, `Inval c)
			;;
		;;
	;;

	-> `std.Err error(x, `Trunc `bio.Eof)
}

const parseattrval = {x
	var start, stop
	var q

	beatspace(x)

	match bnext(x)
	| '"':	q = '"'
	| '\'':	q = '\''
	| c:	-> `std.Err error(x, `Unexpected (c, '"'))
	;;

	start = stop = x.p.bidx

	while true
		while x.p.bidx < x.p.buf.len
			if bnext(x) == q
				-> `std.Ok x.p.buf[start:stop]
			else
				stop = x.p.bidx
			;;
		;;

		match bio.readterm(x.file, ">")
		| `std.Ok s:	expandbuf(x, s)
		| `std.Err e:	-> `std.Err error(x, `Trunc e)
		;;
	;;
	std.die("unreached\n")
}

const parsecdata = {x
	match fillbuf(x, "<![CDATA[", "[CDATA[", "]]>")
	| `std.Ok b:	-> `std.Ok `Cdata b
	| `std.Err e:	-> `std.Err error(x, e)
	;;
}

const parsecomment = {x
	match fillbuf(x, "<!--", "--", "-->")
	| `std.Ok b:	-> `std.Ok `Comment prune(b)
	| `std.Err e:	-> `std.Err error(x, e)
	;;
}

const parsedoctype = {x
	const pref = "DOCTYPE"
	const suf = ">"
	var dt = std.mksb()
	var s, start, open, err
	var q = '"', armed = true

	match bio.readterm(x.file, suf)
	| `std.Ok b:
		newbuf(x, b)
	| `std.Err e:
		err = error(x, `Trunc e)
		goto err
	;;

	if !std.hassuffix(x.p.buf, suf)
		err = error(x, `Unclosed ("<!DOCTYPE", ">"))
		goto err
	;;

	for cc : std.bychar(pref)
		match bnext(x)
		| c:	if c != cc
				err = error(x, `Unexpected (c, cc))
				goto err
			;;
		;;
	;;

	match bnext(x)
	| c:	if !isspace(c)
			err = error(x, `Unexpected (c, ' '))
			goto err
		;;
	;;

	beatspace(x)

	open = 1
	start = x.p.bidx

	while true
		while x.p.bidx < x.p.buf.len
			match bnext(x)
			| '<':
				if armed
					open++
				;;
			| '>':
				if armed
					open--
				;;
			| '"':
				if armed
					armed = false
					q = '"'
				elif q == '"'
					armed = true
				;;
			| '\'':
				if armed
					armed = false
					q = '\''
				elif q == '\''
					armed = true
				;;
			| _:
			;;
		;;

		std.sbputs(dt, x.p.buf)

		if open > 0
			match bio.readterm(x.file, suf)
			| `std.Ok b:
				newbuf(x, b)
			| `std.Err e:
				err = error(x, `Trunc e)
				goto err
			;;

			if !std.hassuffix(x.p.buf, suf)
				err = error(x, `Unclosed ("<!DOCTYPE", ">"))
				goto err
			;;
		else
			break
		;;
	;;

	s = std.sbpeek(dt)
	s = std.sldup(prune(s[start:s.len-suf.len]))
	std.sbfree(dt)
	-> `std.Ok `Doctype s

:err
	std.sbfree(dt)
	-> `std.Err err
}

const parseinstruction = {x
	var start, stop

	match fillbuf(x, "<?", "?", "?>")
	| `std.Ok b:	newbuf(x, std.sldup(b))
	| `std.Err e:	-> `std.Err error(x, e)
	;;

	if x.p.bidx < x.p.buf.len
		match bnext(x)
		| c:	if namestartchar(c)
				start = x.p.bcur
				stop = x.p.bidx
			else
				-> `std.Err error(x, `Inval c)
			;;
		;;
	else
		-> `std.Err error(x, `Empty)
	;;

	while x.p.bidx < x.p.buf.len
		match bnext(x)
		| c:	if namechar(c)
				stop = x.p.bidx
			elif isspace(c)
				beatspace(x)
				break
			else
				-> `std.Err error(x, `Inval c)
			;;
		;;
	;;

	-> `std.Ok `Instruction (x.p.buf[start:stop], x.p.buf[x.p.bidx:])
}

const geterr = {x
	-> x.p.error
}

const error = {x, e
	x.p.more = false
	-> [.line = x.p.line, .off = x.p.off, .err = e]
}
